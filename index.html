<!doctype html>
<html>
    <head>
        <title>Ray casting 3D</title>
        <meta charset='UTF-8' />
        <script src="dist/glsl-component.js"></script>
		<style type="text/css">
			* {
				margin: 0px;
				padding: 0px;
                width: 100%;
                height: 100%;
			}
		</style>
    </head>
    <body>
        <glsl-component>
            precision highp float;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            //uniform vec3 u_pos;
            uniform float u_time;

            const float MAX_DIST = 99999.0;
            const vec3 light = normalize(vec3(-0.5, 0.75, -1.0));

            mat2 rot(in float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, -s, s, c);
            }

            vec2 sphIntersect(in vec3 ro, in vec3 rd, float ra) {
                float b = dot(ro, rd);
                float c = dot(ro, ro) - ra * ra;
                float h = b * b - c;
                if(h < 0.0) return vec2(-1.0);
                h = sqrt(h);
                return vec2(-b - h, -b + h);
            }

            vec2 boxIntersection(in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN)  {
                vec3 m = 1.0 / rd;
                vec3 n = m * ro;
                vec3 k = abs(m) * rad;
                vec3 t1 = -n - k;
                vec3 t2 = -n + k;
                float tN = max(max(t1.x, t1.y), t1.z);
                float tF = min(min(t2.x, t2.y), t2.z);
                if(tN > tF || tF < 0.0) return vec2(-1.0);
                oN = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);
                return vec2(tN, tF);
            }

            float plaIntersect(in vec3 ro, in vec3 rd, in vec4 p) {
                return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);
            }

            vec3 getSky(in vec3 rd) {
                vec3 col = vec3(0.3, 0.6, 1.0);
                vec3 sun = vec3(0.95, 0.9, 1.0);
                sun *= pow(max(0.0, dot(rd, light)), 32.0);
                return clamp(sun + col, 0.0, 1.0);
            }

            vec3 castRay(inout vec3 ro, inout vec3 rd) {
                vec3 col;
                vec2 minIt = vec2(MAX_DIST);
                vec2 it;
                vec3 n;
                vec3 spherePos = vec3(0.0, -1.0, 0.0);
                it = sphIntersect(ro - spherePos, rd, 1.0);
                if(it.x > 0.0 && it.x < minIt.x) {
                    minIt = it;
                    vec3 itPos = ro + rd * it.x;
                    n = itPos - spherePos;
                    col = vec3(1.0, 0.2, 0.1);
                }
                vec3 boxN;
                vec3 boxPos = vec3(0.0, 2.0, 0.0);
                it = boxIntersection(ro - boxPos, rd, vec3(1.0), boxN);
                if(it.x > 0.0 && it.x < minIt.x) {
                    minIt = it;
                    n = boxN;
                    col = vec3(0.4, 0.6, 0.8);
                }
                vec3 planeNormal = vec3(0.0, 0.0, -1.0);
                it = vec2(plaIntersect(ro, rd, vec4(planeNormal, 1.0)));
                if(it.x > 0.0 && it.x < minIt.x) {
                    minIt = it;
                    n = planeNormal;
                    col = vec3(0.5);
                }
                if(minIt.x == MAX_DIST) return vec3(-1.0);
                float diffuse = dot(light, n) * 0.5 + 0.5;
                float specular = pow(max(0.0, dot(reflect(rd, n), light)), 32.0) * 2.0;
                col *= mix(diffuse, specular, 0.5);
                ro += rd * (minIt.x - 0.001);
                rd = n;
                return col;
            }

            vec3 traceRay(in vec3 ro, in vec3 rd) {
                vec3 col = castRay(ro, rd);
                if(col.x < 0.0) return getSky(rd);
                vec3 lightDir = light;
                if(dot(rd, light) > 0.0) {
                    if(castRay(ro, lightDir).x != -1.0) col *= 0.5;
                }
                return col;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.y - vec2(1.0, 0.5);
                vec3 rayOrigin = vec3(-5.0, 0.0, 0.0);
                vec3 rayDirection = normalize(vec3(1.0, uv));
                vec2 mouse = (-u_mouse / u_resolution - vec2(0.5)) * 3.0;
                rayDirection.zx *= rot(mouse.y);
                rayDirection.xy *= rot(mouse.x);
                vec3 col = traceRay(rayOrigin, rayDirection);
                col = pow(col, vec3(0.45));
                gl_FragColor = vec4(col, 1.0);
            }
        </glsl-component>
    </body>
</html>